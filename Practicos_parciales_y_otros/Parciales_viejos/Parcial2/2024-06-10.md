# Ejercicio 1 (Algoritmo Voraces)

### En la juntada del sabado con tus amigos, te mandan a comprar K porciones de helado. Luego de una discusion acalorada, lograron ponerse de acuerdo, asignando a cada sabor i de los N disponibls en la heladeria, un puntaje no negativo $p_i$, y decidieron no repetir ningun sabor. Ademas, para cada sabor i se sabe si el mismo es al agua o no, mediante un booleano $a_i$. Se debe encontrar el mayor puntaje obtenible eligiendo K gustos distintos de helado, con la condicion de que al menos M gustos sean al agua.

#### (a) Indicar de manera simple y concreta, cual es el criterio de selección voraz para construir la solución?

Voy a elegir 








# Ejercicio 2 (Backtracking)

### La juntada entre amigos del ejercicio anterior se extendio mas de lo esperado y ya llego el domingo al mediodia. Quieren volver a pedir helado pero con cierta consistencia saludable, deciden no consumir demasiadas calorias. Para ello, cada gusto de helado i de los N disponibles, ademas del puntaje $p_i$ tambien tiene asignado un valor $c_i$ de calorias que contiene la porcion. 
### Se debe encontrar el mayor puntaje obtenible eligiendo K gustos de helado, sin superar el total de calorias C y eligiendo al menos M gustos al agua.

````
NOTAS:

debo calcular el mayor puntaje, por lo que usare max;
debo haber M gustos al agua, asi que mientras aun tenga que cumplir esta condicion tengo que tratar de preferir los gustos al agua.

COMO REGISTRO QUE ES AL AGUA?

* Si ya no se puede agregar sabores porque se sobrepaso el total C y todavia no se alcanzo la cantidad M de sabores al agua entonces $-\infty$.
-> No se si este entra como caso o ya esta tapado por otro

````
Casos:
* Si ya se cumplio la cantidad M de sabores al agua y la cantidad K de sabores sin superar la cantidad total de calorias C entonces 0.

* Si no hay mas sabores $(i=0)$, y no se cumplió la cantidad K de sabores tales $(K\neq 0)$ o la cantidad M de sabores al agua $(M\neq 0)$ entonces $-\infty$.
* Si el sabor actual $(i\neq 0)$ no sobrepasa C, no es al agua $(a_i = 0)$ y aun se necesita agregar sabores $(K\neq 0)$ veo si lo agrego o no.
* Si el sabor actual $(i\neq 0)$ no sobrepasa C, es al agua $(a_i= 1)$ y aun se necesita agregar sabores $(K\neq 0)$ veo si lo agrego o no, actualizando o no ademas M. 
* Si el sabor actual sobrepasa C se descarta.

***maxPuntSdbl(i,M,C)***="Determina el mayor puntaje obtenible eligiendo **K** sabores entre $1,\dots,i$ sabores con, respectivamente, puntajes $p_1,\dots,p_i$, calorias por porcion $c_1,\dots,c_i$ y $a_1,\dots,a_i$ que indica si es al agua ($a_k$ = 0 o 1, 1 si es al agua y 0 si no lo es), cumpliendo ademas con que haya **M** sabores al agua y no se sobrepase el total de calorias **C**."

$$
maxPuntSdbl(i,K,M,C) =
\left\lbrace
\begin{array}{ll}
0 & \text{si } (M = 0)\land(K=0)\\
-\infty & \text{si } ((M \gt 0)\lor(K \gt 0))\land(i=0) \\
maxPuntSdbl(i-1,K,M,C) &\text{si } c_i \gt C \\
\max(maxPuntSdbl(i-1,K,M,C),p_i + maxPuntSdbl(i-1,K-1,M,C-c_i)) &\text{si } (c_i \le C)\land(K\gt 0)\land(a_i = 0) \\
\max(maxPuntSdbl(i-1,K,M,C),p_i + maxPuntSdbl(i-1,K-1,M-1,C-c_i)) &\text{si } (c_i \le C)\land(K\gt 0)\land(a_i = 1)\\
\end{array}
\right.
$$

La llamada principal seria: ***maxPuntSdbl*(n,K,M,C)**.

# Ejercicio 3

### Implementa un algoritmo que utilice PD para resolver el problema del punto anterior. Para ello primero responde:

#### ¿Que dimensiones tiene la tabla que el algoritmo debe llenar?

Las dimensiones de la tabla que deberia llenar el algoritmo será de 4 dimensiones, de la forma tabla[0..n,0..K,0..M,0..C] con:
* n cantidad de sabores
* K cantidad de sabores a elegir
* M cantidad de sabores al agua requeridos
* C cantidad maxima de calorias permitidas

#### ¿En que orden se llena la misma?

Primero se llena en el orden siguiente: dimension de cantidad de sabores 0..n, dimension de sabores a elegir 0..K, dimension de sabores al agua requeridos 0..M y dimension de calorias permitidas 0..C, todas de menor a mayor.
 
#### ¿Se podria llenar de otra forma? En caso afirmativo indique cual.

No se podria llenar de otra manera puesto que cada dimension depende de los valores calculados previamente.

````c
fun maxPuntPD(p:array[1..n] of nat, c:array[1..n] of nat, a:array[1..n] of Bool, K:nat, M:nat, C:nat) ret res: nat

    //Primero creo la tabla multidimensional.
    var tabla: array[0..n,0..K,0..M,0..C]

    /*Casos base:
        Si ya miré todos los sabores (i=0) y cumpli con la cantidad K (K=0) y la cantidad M (M=0) sin sobrepasar C (C >= 0) entonces cumplí mi objetivo y solo sumo 0 a la puntuacion.

        Pero si ya mire todos los sabores y no cumpli con las cantidades K o M, indistintamente del valor actual de C FALLO LA SELECCION, por lo que se debe descartar sumando -∞ (absorve).
    */
    for i=0 to n do
        for k=0 to K do
            for m=0 to M do
                for c1=0 to C do
                    if ((k == 0) && (m == 0)) then
                        tabla[i,0,0,c1] := 0
                    else if (((k > 0) || (m > 0)) && (i == 0))
                        tabla[i,k,m,c1] := -∞
                    fi
                od
            od
        od
    od

    //Paso recursivo 
    for i=1 to n do
        for k = 1 to K do
            for m = 1 to M do
                for z=1 to C do
                    //Verifica si ci > C
                    if (c[i] > z) then
                        tabla[i,k,m,z] = tabla[i-1,k,m,z]
                    else if ((c[i] <= z) && (a[i]=True)) then //Caso pruebo si agregar o no y es de agua
                        tabla[i,k,m,z] = max(tabla[i-1,k,m,z],p[i]+tabla[i-1,k-1,m-1,z-c[i]])
                    else if ((c[i] <= z) && (a[i]=False)) then
                        tabla[i,k,m,z] = max(tabla[i-1,k,m,z],p[i]+tabla[i-1,k-1,m,z-c[i]])
                    fi
                od
            od
        od
    od
    //Resultado: llamada principal
    res = tabla[n,K,M,C]
````
